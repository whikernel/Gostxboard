/****************************************************/
//   Fiche d'évolution du driver AvfiKeyboadHook	//
// 				     Version 1.1					//
//					24 / 07 / 2014					//	
// 		   Licence Paul Amicelli Pour Davfi			//
//			p.amicelli@uhuru-solutions.com			//
/****************************************************/

------
NOTA : Pour les différentes étapes d'évolutions au court de
		du développement, se référrer aux notes de versions 
		présentes dans le fichier resources.txt du projet
		AvfiDriver. 

		
#------------#
# Version 1.0     
#------------#
    >>>>>> Le driver doit se placer dans la stack des drivers 
	|	keyboards. Sa place dans la stack n'est pas importante
	|	pour le moment. L'utilisation de la routine "AddDevice"
	|	n'est pas adapté dans le sens où elle n'est appelée que 
	|	lorsqu'un nouveau périphérique est présenté au système, 
	|	ce qui arrive rarement pour un clavier. Le lancement
	|	du driver ne sera pas effectif puisqu'aucun périphérique
	|	ne lui sera fournis et une erreur sera levée.
	|
	|SOLUTION <<<<<<<<<<<<<<<<<
	|	|	L'implémentation d'une routine d'initialisation et
	|	|	de création du device permet de régler ce problème. 
	|	|	On créer un nouveau device de type clavier, puis on 
	|	|	récupère l'objet clavier actuel grâce à son nom 
	|	|	"\\Device\\KeyboardClass0". Il suffit alors de 
	|	|	s'attacher à la stack du driver qu'on vient de 
	|	|	récupérer.
	|
				 >>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> A l'appui d'une touche quelconque sur le clavier, le 
	|	système génère une erreur. Le driver ne semble pas régir 
	|	aux IRP bien que les routines de dispatches soient 
	|	enregistrées. La touche pressé apparait bien à l'écran, signe 
	|	que l'IRP a bien remonté la stack. Cependant aucun signe de
	|	passage de l'IRP dans le driver.
	|	Les drivers kdbclass.sys et i8042prt.sys de Windows génèrent 
	|	une erreur DRIVER_IRQL_NOT_LESS_OR_EQUAL (d1) signalant qu'un 
	|	accès à de la mémoire paginable ou invalide a été effectué à 
	|	une IRQL trop élevée. 
	|
	|	#======Paramètres=======
	|	|< 	Erreur : DRIVER_IRQL_NOT_LESS_OR_EQUAL (d1)
	|	|<  Opération : Ecriture (0x1) à 0x0
	|	|< 	IRQL : 2 
	|	|<	Cause : kbdclass.sys ( + 4954)
	|	#=========FIN===========
	|	
	|	Un "!drvobj <Driver>" suivie d'un "!devobj <addr>" dans le 
	|	windbg permet de voir que le driver est situé juste au 
	|	dessus du driver kbdclass, source de l'erreur. 
	|	Un "!drvobj <driver> 2" permet de voir les différentes 
	|	routines enregistrées pour notre driver. Tout est dans l'ordre
	|	à ce niveau.
	|   <NOTE : En dessous du driver i8042prt se trouve l'ACPI. A voir
	|    pour descendre dans la stack>
	|	La mise en place de breakpoints sur les différentes routines de 
	|	dispatches permettent de déterminer qu'à l'appuie d'une touche, 
	|   la routine ReadDispatch est appelée. La poursuite de l'exécution
	|	amène au crash. La routine Read ou ReadCompletion parait donc en 
	|	cause. Un test avec seulement la routine amène aux mêmes resulats,
	|	signe que l'erreur vient des objets passé en paramètres lors de 
	| 	l'appel aux fonctions IoCallDriver
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	L'oublie des flags lors de l'attachement d'un objet à la stack
	|	| 	provoque ce genre d'erreurs
	|		
				 >>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
				 
#------------#
# Version 1.1     
#------------#
	>>>>>> La création d'un fichier au niveau IRQL 2 amène à une erreur
	|	IRQL_NOT_LESS_OR_EQUAL signifiant qu'un accès à de la mémoire 
	|	paginable, trop élevé a été effectué. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	L'IRQL est trop élevée. Il faut créer un thread annexe et lui 
	| 	| 	confier la tâche d'écriture. Les Worker Threads semblent 
	|	|	adaptées. 
	|
				 >>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> L'initialization d'un WorkerItem avec la routine 
	|	ExInitializeWorkItem déclenche une erreur de type 
	|	IRQL_NOT_LESS_OR_EQUAL signifiant qu'un accès à de la mémoire 
	|	paginable, trop élevé a été effectué.
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	Vérifier que le WorkerItem a bien été alloué avec de
	| 	| 	la mémoire non paginable. 
	|
				 >>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> L'utilisation de la fonction RtlCopyMemory sur des structures 
	|	passés en user mode par des IOCTL ne semble pas fonctionner. 
	|	Lutilisation de ces fonctions sur de simples buffers semble fonc-
	|	tionner. Aucune erreur n'est levée, mais la copie n'est pas 
	|	effective. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	La modification directe de la structure recu ne semble pas 
	|	| 	pas fonctionner. L'initialisation d'une nouvelle structure 
	|	| 	identique permet d'outrepasser ce problème. Il ne faut oublier
	|	| 	de préciser qu'il s'agit de la structure de retour en précisant
	|	| 	le pointeur du buffer :  
	|	|   StrctReturn = (PPUBLIC_KEY_INIT)Irp->AssociatedIrp.SystemBuffer;
	|
				>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> La mise en place d'un chiffrement des données amène à chiffrer
	|	le clavier entier à cause des scan-codes. Or l'interpréation des 
	|	données par Windows seafait bien avant l'arrivées aux applications. 
	|	Ainsi l'appuie sur une touche de l'alphabet peut générer une Volume 
	|	Up par exemple. D'autre part les touches vitales 'Ctrl Alt Suppr" ne
	|	sont plus disponible. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	Mettre en place un système de black-liste générique, permettant
	|	| 	de sauter le chiffrement pour les touches vitales. 
	|
				>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> L'appuie long sur une touche amène le système à les mettres en fils
	|	d'attente. or le temps de traitement ne permet pas de traiter toutes 
	|	les requetes.
	
	
					>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> La copie de la table de permutation en début de fonction ShuffleTab
	|	n'est pas complétement effective. La copie est effectuée grâce à la fo-
	|	fonction RtlCopyMemory. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	Réaliser la copie dans une fonction externe permet de résoudre le 
	|	| 	le problème. La cause en est inconnue.
	
					>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> Lors de l'appuie sur une touche du clavier, le driver reçoit une 
	|	double IRP. Ceci ne vient pas des drivers inférieur. L'IRP passe en 
	|	effet deux fois dans la routine de complétion sans sortir de la rou
	|	-tine de lecture. La cause n'est pas connu, bien qu'il s'agisse sûr
	|	-ment d'une mauvaise complétion de l'IRP.	
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	| 	La mise en place d'un système permettant de ne passer qu'une fois
	|	| 	dans la routine de complétion par routine de lecture, permet de 
	|	|	regler le problème, bien que ceci ne soit pas très protocolaire.
	
					>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> Lors du mappage d'un scan code recu en VKCode,  Windows considère
	|	qu'il s'agit d'une majuscule alors que ce n'est clairement pas le  
	|	cas. La touche n'est pourtant pas activée selon lui.  	
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	La fonction VkKeyScanA permet de récupérer le scan code correspond-
	|	|	-ant au charactère appuyé sous la forme d'un SHORT. Dans ce short
	|	| 	la partie haute contient un indicateur de touches spéciales, la 
	|	| 	la partie basse contient le scan-code. Les bits de poids fort 
	|	|   permettent donc de savoir s'il la touche shift est appuyée. A partir
	|	|   de là, on enregistre la casse, et on considère qu'il s'agit d'une 
	|	| 	minuscule (la maj fait bugue la fonction de mappage). Une fois que 
	|	| 	l'on a déchiffré le scan code, on rajoute la casse en fonction de 
	|	| 	son etat précédent.

					>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<	
	
	>>>>>> En mode non débug, la vitesse de chiffrement est si élevée que le module
	|	reçoit "trop" d'IRPs pour une touche données (>2). Le chiffrement est 
	|	donc complétement décalé par rapport à l'application tierce. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	L'implémentation d'un algorithme de selection des IRPS permet de 
	|	|	de palier à ce problème. Le résultat est jugé acceptable mais non 
	|	| 	parfait. A améliorer. 
	
				>>>>>>>>>>>>>> * <<<<<<<<<<<<<<<
	
	>>>>>> L'API de Windows propose une fonction SetWindowsHook permettant de 
	|	créer des hooks. De pair avec la fonction de callback LowLevelKeyboardHook, 
	|	elle permet de récupérer les entrés, avant le driver. Le driver n'est donc 
	|	plus effectif. 
	|
	|SOLUTION <<<<<<<<<<<<<<<<<<
	|	|	L'enregistrement du driver en tant que LowerFilter permettrait de
	|	| 	de se placer en dessous du hook de windows. A voir ..
	|	|    ---- En se placant en lowerfilter ( ajout de la sous-clé de registre Lowerfilters dans
	|	| 	la clé : 
	|	| HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4D36E96B-E325-11CE-BFC1-08002BE10318} )
	|	|  Le driver se lance au démarrage et se place en dessous du driver i8042prt.
	|	| La place semble bonne mais seule la récéption d'IRP PNP es effective. 
	|	| 	Il semble impossible de récuperer les scans codes claviers. En modifiant la sous 
	|	| clé de registre Upperfilter, et en mettant le nom du driver en première position on 
	|	| se retrouve entre le driver kbdclass et i8042prt. La place semble bonne. 
	 
	
	
	
	
	
	
	
	
	
	
	
	
	